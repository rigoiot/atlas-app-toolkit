// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: query/collection_operators.proto

package query // import "github.com/rigoiot/atlas-app-toolkit/query"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import encoding_binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Order is a sort order.
type SortCriteria_Order int32

const (
	// ascending sort order
	SortCriteria_ASC SortCriteria_Order = 0
	// descending sort order
	SortCriteria_DESC SortCriteria_Order = 1
)

var SortCriteria_Order_name = map[int32]string{
	0: "ASC",
	1: "DESC",
}
var SortCriteria_Order_value = map[string]int32{
	"ASC":  0,
	"DESC": 1,
}

func (x SortCriteria_Order) String() string {
	return proto.EnumName(SortCriteria_Order_name, int32(x))
}
func (SortCriteria_Order) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{0, 0}
}

type LogicalOperator_Type int32

const (
	LogicalOperator_AND LogicalOperator_Type = 0
	LogicalOperator_OR  LogicalOperator_Type = 1
)

var LogicalOperator_Type_name = map[int32]string{
	0: "AND",
	1: "OR",
}
var LogicalOperator_Type_value = map[string]int32{
	"AND": 0,
	"OR":  1,
}

func (x LogicalOperator_Type) String() string {
	return proto.EnumName(LogicalOperator_Type_name, int32(x))
}
func (LogicalOperator_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{5, 0}
}

type StringCondition_Type int32

const (
	StringCondition_EQ    StringCondition_Type = 0
	StringCondition_MATCH StringCondition_Type = 1
	StringCondition_GT    StringCondition_Type = 2
	StringCondition_GE    StringCondition_Type = 3
	StringCondition_LT    StringCondition_Type = 4
	StringCondition_LE    StringCondition_Type = 5
	StringCondition_IEQ   StringCondition_Type = 6
)

var StringCondition_Type_name = map[int32]string{
	0: "EQ",
	1: "MATCH",
	2: "GT",
	3: "GE",
	4: "LT",
	5: "LE",
	6: "IEQ",
}
var StringCondition_Type_value = map[string]int32{
	"EQ":    0,
	"MATCH": 1,
	"GT":    2,
	"GE":    3,
	"LT":    4,
	"LE":    5,
	"IEQ":   6,
}

func (x StringCondition_Type) String() string {
	return proto.EnumName(StringCondition_Type_name, int32(x))
}
func (StringCondition_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{6, 0}
}

type NumberCondition_Type int32

const (
	NumberCondition_EQ NumberCondition_Type = 0
	NumberCondition_GT NumberCondition_Type = 1
	NumberCondition_GE NumberCondition_Type = 2
	NumberCondition_LT NumberCondition_Type = 3
	NumberCondition_LE NumberCondition_Type = 4
)

var NumberCondition_Type_name = map[int32]string{
	0: "EQ",
	1: "GT",
	2: "GE",
	3: "LT",
	4: "LE",
}
var NumberCondition_Type_value = map[string]int32{
	"EQ": 0,
	"GT": 1,
	"GE": 2,
	"LT": 3,
	"LE": 4,
}

func (x NumberCondition_Type) String() string {
	return proto.EnumName(NumberCondition_Type_name, int32(x))
}
func (NumberCondition_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{7, 0}
}

type StringArrayCondition_Type int32

const (
	StringArrayCondition_IN StringArrayCondition_Type = 0
)

var StringArrayCondition_Type_name = map[int32]string{
	0: "IN",
}
var StringArrayCondition_Type_value = map[string]int32{
	"IN": 0,
}

func (x StringArrayCondition_Type) String() string {
	return proto.EnumName(StringArrayCondition_Type_name, int32(x))
}
func (StringArrayCondition_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{9, 0}
}

type NumberArrayCondition_Type int32

const (
	NumberArrayCondition_IN NumberArrayCondition_Type = 0
)

var NumberArrayCondition_Type_name = map[int32]string{
	0: "IN",
}
var NumberArrayCondition_Type_value = map[string]int32{
	"IN": 0,
}

func (x NumberArrayCondition_Type) String() string {
	return proto.EnumName(NumberArrayCondition_Type_name, int32(x))
}
func (NumberArrayCondition_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{10, 0}
}

// SortCriteria represents sort criteria
type SortCriteria struct {
	// Tag is a JSON tag.
	Tag                  string             `protobuf:"bytes,1,opt,name=tag,proto3" json:"tag,omitempty"`
	Order                SortCriteria_Order `protobuf:"varint,2,opt,name=order,proto3,enum=infoblox.api.SortCriteria_Order" json:"order,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SortCriteria) Reset()         { *m = SortCriteria{} }
func (m *SortCriteria) String() string { return proto.CompactTextString(m) }
func (*SortCriteria) ProtoMessage()    {}
func (*SortCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{0}
}
func (m *SortCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SortCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SortCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SortCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SortCriteria.Merge(dst, src)
}
func (m *SortCriteria) XXX_Size() int {
	return m.Size()
}
func (m *SortCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_SortCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_SortCriteria proto.InternalMessageInfo

func (m *SortCriteria) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

func (m *SortCriteria) GetOrder() SortCriteria_Order {
	if m != nil {
		return m.Order
	}
	return SortCriteria_ASC
}

// Sorting represents list of sort criterias.
type Sorting struct {
	Criterias            []*SortCriteria `protobuf:"bytes,1,rep,name=criterias,proto3" json:"criterias,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Sorting) Reset()         { *m = Sorting{} }
func (m *Sorting) String() string { return proto.CompactTextString(m) }
func (*Sorting) ProtoMessage()    {}
func (*Sorting) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{1}
}
func (m *Sorting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sorting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sorting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Sorting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sorting.Merge(dst, src)
}
func (m *Sorting) XXX_Size() int {
	return m.Size()
}
func (m *Sorting) XXX_DiscardUnknown() {
	xxx_messageInfo_Sorting.DiscardUnknown(m)
}

var xxx_messageInfo_Sorting proto.InternalMessageInfo

func (m *Sorting) GetCriterias() []*SortCriteria {
	if m != nil {
		return m.Criterias
	}
	return nil
}

// FieldSelection represents a group of fields for some object.
// Main use case for if is to store information about object fields that
// need to be ratained prior to sending object as a response
type FieldSelection struct {
	// option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
	//     json_schema: {
	//         type: STRING;
	//         description: "atlas.api.field_selection";
	//     };
	// };
	Fields               map[string]*Field `protobuf:"bytes,1,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FieldSelection) Reset()         { *m = FieldSelection{} }
func (m *FieldSelection) String() string { return proto.CompactTextString(m) }
func (*FieldSelection) ProtoMessage()    {}
func (*FieldSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{2}
}
func (m *FieldSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FieldSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FieldSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *FieldSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FieldSelection.Merge(dst, src)
}
func (m *FieldSelection) XXX_Size() int {
	return m.Size()
}
func (m *FieldSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_FieldSelection.DiscardUnknown(m)
}

var xxx_messageInfo_FieldSelection proto.InternalMessageInfo

func (m *FieldSelection) GetFields() map[string]*Field {
	if m != nil {
		return m.Fields
	}
	return nil
}

// Field represents a single field for an object.
// It contains fields name and also may contain a group of sub-fields for cases
// when a fields represents some structure.
type Field struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Subs                 map[string]*Field `protobuf:"bytes,2,rep,name=subs,proto3" json:"subs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Field) Reset()         { *m = Field{} }
func (m *Field) String() string { return proto.CompactTextString(m) }
func (*Field) ProtoMessage()    {}
func (*Field) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{3}
}
func (m *Field) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Field) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Field.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Field) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Field.Merge(dst, src)
}
func (m *Field) XXX_Size() int {
	return m.Size()
}
func (m *Field) XXX_DiscardUnknown() {
	xxx_messageInfo_Field.DiscardUnknown(m)
}

var xxx_messageInfo_Field proto.InternalMessageInfo

func (m *Field) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Field) GetSubs() map[string]*Field {
	if m != nil {
		return m.Subs
	}
	return nil
}

// Filtering represents filtering expression.
// root could be either LogicalOperator or one of the supported conditions.
type Filtering struct {
	// Types that are valid to be assigned to Root:
	//	*Filtering_Operator
	//	*Filtering_StringCondition
	//	*Filtering_NumberCondition
	//	*Filtering_NullCondition
	//	*Filtering_StringArrayCondition
	//	*Filtering_NumberArrayCondition
	Root                 isFiltering_Root `protobuf_oneof:"root"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Filtering) Reset()         { *m = Filtering{} }
func (m *Filtering) String() string { return proto.CompactTextString(m) }
func (*Filtering) ProtoMessage()    {}
func (*Filtering) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{4}
}
func (m *Filtering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filtering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filtering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Filtering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filtering.Merge(dst, src)
}
func (m *Filtering) XXX_Size() int {
	return m.Size()
}
func (m *Filtering) XXX_DiscardUnknown() {
	xxx_messageInfo_Filtering.DiscardUnknown(m)
}

var xxx_messageInfo_Filtering proto.InternalMessageInfo

type isFiltering_Root interface {
	isFiltering_Root()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Filtering_Operator struct {
	Operator *LogicalOperator `protobuf:"bytes,1,opt,name=operator,proto3,oneof"`
}
type Filtering_StringCondition struct {
	StringCondition *StringCondition `protobuf:"bytes,2,opt,name=string_condition,json=stringCondition,proto3,oneof"`
}
type Filtering_NumberCondition struct {
	NumberCondition *NumberCondition `protobuf:"bytes,3,opt,name=number_condition,json=numberCondition,proto3,oneof"`
}
type Filtering_NullCondition struct {
	NullCondition *NullCondition `protobuf:"bytes,4,opt,name=null_condition,json=nullCondition,proto3,oneof"`
}
type Filtering_StringArrayCondition struct {
	StringArrayCondition *StringArrayCondition `protobuf:"bytes,5,opt,name=string_array_condition,json=stringArrayCondition,proto3,oneof"`
}
type Filtering_NumberArrayCondition struct {
	NumberArrayCondition *NumberArrayCondition `protobuf:"bytes,6,opt,name=number_array_condition,json=numberArrayCondition,proto3,oneof"`
}

func (*Filtering_Operator) isFiltering_Root()             {}
func (*Filtering_StringCondition) isFiltering_Root()      {}
func (*Filtering_NumberCondition) isFiltering_Root()      {}
func (*Filtering_NullCondition) isFiltering_Root()        {}
func (*Filtering_StringArrayCondition) isFiltering_Root() {}
func (*Filtering_NumberArrayCondition) isFiltering_Root() {}

func (m *Filtering) GetRoot() isFiltering_Root {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *Filtering) GetOperator() *LogicalOperator {
	if x, ok := m.GetRoot().(*Filtering_Operator); ok {
		return x.Operator
	}
	return nil
}

func (m *Filtering) GetStringCondition() *StringCondition {
	if x, ok := m.GetRoot().(*Filtering_StringCondition); ok {
		return x.StringCondition
	}
	return nil
}

func (m *Filtering) GetNumberCondition() *NumberCondition {
	if x, ok := m.GetRoot().(*Filtering_NumberCondition); ok {
		return x.NumberCondition
	}
	return nil
}

func (m *Filtering) GetNullCondition() *NullCondition {
	if x, ok := m.GetRoot().(*Filtering_NullCondition); ok {
		return x.NullCondition
	}
	return nil
}

func (m *Filtering) GetStringArrayCondition() *StringArrayCondition {
	if x, ok := m.GetRoot().(*Filtering_StringArrayCondition); ok {
		return x.StringArrayCondition
	}
	return nil
}

func (m *Filtering) GetNumberArrayCondition() *NumberArrayCondition {
	if x, ok := m.GetRoot().(*Filtering_NumberArrayCondition); ok {
		return x.NumberArrayCondition
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Filtering) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Filtering_OneofMarshaler, _Filtering_OneofUnmarshaler, _Filtering_OneofSizer, []interface{}{
		(*Filtering_Operator)(nil),
		(*Filtering_StringCondition)(nil),
		(*Filtering_NumberCondition)(nil),
		(*Filtering_NullCondition)(nil),
		(*Filtering_StringArrayCondition)(nil),
		(*Filtering_NumberArrayCondition)(nil),
	}
}

func _Filtering_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Filtering)
	// root
	switch x := m.Root.(type) {
	case *Filtering_Operator:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Operator); err != nil {
			return err
		}
	case *Filtering_StringCondition:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringCondition); err != nil {
			return err
		}
	case *Filtering_NumberCondition:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NumberCondition); err != nil {
			return err
		}
	case *Filtering_NullCondition:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NullCondition); err != nil {
			return err
		}
	case *Filtering_StringArrayCondition:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StringArrayCondition); err != nil {
			return err
		}
	case *Filtering_NumberArrayCondition:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NumberArrayCondition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Filtering.Root has unexpected type %T", x)
	}
	return nil
}

func _Filtering_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Filtering)
	switch tag {
	case 1: // root.operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalOperator)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_Operator{msg}
		return true, err
	case 2: // root.string_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_StringCondition{msg}
		return true, err
	case 3: // root.number_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_NumberCondition{msg}
		return true, err
	case 4: // root.null_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NullCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_NullCondition{msg}
		return true, err
	case 5: // root.string_array_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringArrayCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_StringArrayCondition{msg}
		return true, err
	case 6: // root.number_array_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberArrayCondition)
		err := b.DecodeMessage(msg)
		m.Root = &Filtering_NumberArrayCondition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Filtering_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Filtering)
	// root
	switch x := m.Root.(type) {
	case *Filtering_Operator:
		s := proto.Size(x.Operator)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_StringCondition:
		s := proto.Size(x.StringCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_NumberCondition:
		s := proto.Size(x.NumberCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_NullCondition:
		s := proto.Size(x.NullCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_StringArrayCondition:
		s := proto.Size(x.StringArrayCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Filtering_NumberArrayCondition:
		s := proto.Size(x.NumberArrayCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// LogicalOperator represents binary logical operator, either AND or OR depending on type.
// left and right are respectively left and right operands of the operator, could be
// either LogicalOperator or one of the supported conditions.
// is_negative is set to true if the operator is negated.
type LogicalOperator struct {
	// Types that are valid to be assigned to Left:
	//	*LogicalOperator_LeftOperator
	//	*LogicalOperator_LeftStringCondition
	//	*LogicalOperator_LeftNumberCondition
	//	*LogicalOperator_LeftNullCondition
	//	*LogicalOperator_LeftStringArrayCondition
	//	*LogicalOperator_LeftNumberArrayCondition
	Left isLogicalOperator_Left `protobuf_oneof:"left"`
	// Types that are valid to be assigned to Right:
	//	*LogicalOperator_RightOperator
	//	*LogicalOperator_RightStringCondition
	//	*LogicalOperator_RightNumberCondition
	//	*LogicalOperator_RightNullCondition
	//	*LogicalOperator_RightStringArrayCondition
	//	*LogicalOperator_RightNumberArrayCondition
	Right                isLogicalOperator_Right `protobuf_oneof:"right"`
	Type                 LogicalOperator_Type    `protobuf:"varint,9,opt,name=type,proto3,enum=infoblox.api.LogicalOperator_Type" json:"type,omitempty"`
	IsNegative           bool                    `protobuf:"varint,10,opt,name=is_negative,json=isNegative,proto3" json:"is_negative,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *LogicalOperator) Reset()         { *m = LogicalOperator{} }
func (m *LogicalOperator) String() string { return proto.CompactTextString(m) }
func (*LogicalOperator) ProtoMessage()    {}
func (*LogicalOperator) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{5}
}
func (m *LogicalOperator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogicalOperator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogicalOperator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LogicalOperator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogicalOperator.Merge(dst, src)
}
func (m *LogicalOperator) XXX_Size() int {
	return m.Size()
}
func (m *LogicalOperator) XXX_DiscardUnknown() {
	xxx_messageInfo_LogicalOperator.DiscardUnknown(m)
}

var xxx_messageInfo_LogicalOperator proto.InternalMessageInfo

type isLogicalOperator_Left interface {
	isLogicalOperator_Left()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isLogicalOperator_Right interface {
	isLogicalOperator_Right()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LogicalOperator_LeftOperator struct {
	LeftOperator *LogicalOperator `protobuf:"bytes,1,opt,name=left_operator,json=leftOperator,proto3,oneof"`
}
type LogicalOperator_LeftStringCondition struct {
	LeftStringCondition *StringCondition `protobuf:"bytes,2,opt,name=left_string_condition,json=leftStringCondition,proto3,oneof"`
}
type LogicalOperator_LeftNumberCondition struct {
	LeftNumberCondition *NumberCondition `protobuf:"bytes,3,opt,name=left_number_condition,json=leftNumberCondition,proto3,oneof"`
}
type LogicalOperator_LeftNullCondition struct {
	LeftNullCondition *NullCondition `protobuf:"bytes,4,opt,name=left_null_condition,json=leftNullCondition,proto3,oneof"`
}
type LogicalOperator_LeftStringArrayCondition struct {
	LeftStringArrayCondition *StringArrayCondition `protobuf:"bytes,11,opt,name=left_string_array_condition,json=leftStringArrayCondition,proto3,oneof"`
}
type LogicalOperator_LeftNumberArrayCondition struct {
	LeftNumberArrayCondition *NumberArrayCondition `protobuf:"bytes,12,opt,name=left_number_array_condition,json=leftNumberArrayCondition,proto3,oneof"`
}
type LogicalOperator_RightOperator struct {
	RightOperator *LogicalOperator `protobuf:"bytes,5,opt,name=right_operator,json=rightOperator,proto3,oneof"`
}
type LogicalOperator_RightStringCondition struct {
	RightStringCondition *StringCondition `protobuf:"bytes,6,opt,name=right_string_condition,json=rightStringCondition,proto3,oneof"`
}
type LogicalOperator_RightNumberCondition struct {
	RightNumberCondition *NumberCondition `protobuf:"bytes,7,opt,name=right_number_condition,json=rightNumberCondition,proto3,oneof"`
}
type LogicalOperator_RightNullCondition struct {
	RightNullCondition *NullCondition `protobuf:"bytes,8,opt,name=right_null_condition,json=rightNullCondition,proto3,oneof"`
}
type LogicalOperator_RightStringArrayCondition struct {
	RightStringArrayCondition *StringArrayCondition `protobuf:"bytes,13,opt,name=right_string_array_condition,json=rightStringArrayCondition,proto3,oneof"`
}
type LogicalOperator_RightNumberArrayCondition struct {
	RightNumberArrayCondition *NumberArrayCondition `protobuf:"bytes,14,opt,name=right_number_array_condition,json=rightNumberArrayCondition,proto3,oneof"`
}

func (*LogicalOperator_LeftOperator) isLogicalOperator_Left()               {}
func (*LogicalOperator_LeftStringCondition) isLogicalOperator_Left()        {}
func (*LogicalOperator_LeftNumberCondition) isLogicalOperator_Left()        {}
func (*LogicalOperator_LeftNullCondition) isLogicalOperator_Left()          {}
func (*LogicalOperator_LeftStringArrayCondition) isLogicalOperator_Left()   {}
func (*LogicalOperator_LeftNumberArrayCondition) isLogicalOperator_Left()   {}
func (*LogicalOperator_RightOperator) isLogicalOperator_Right()             {}
func (*LogicalOperator_RightStringCondition) isLogicalOperator_Right()      {}
func (*LogicalOperator_RightNumberCondition) isLogicalOperator_Right()      {}
func (*LogicalOperator_RightNullCondition) isLogicalOperator_Right()        {}
func (*LogicalOperator_RightStringArrayCondition) isLogicalOperator_Right() {}
func (*LogicalOperator_RightNumberArrayCondition) isLogicalOperator_Right() {}

func (m *LogicalOperator) GetLeft() isLogicalOperator_Left {
	if m != nil {
		return m.Left
	}
	return nil
}
func (m *LogicalOperator) GetRight() isLogicalOperator_Right {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *LogicalOperator) GetLeftOperator() *LogicalOperator {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftOperator); ok {
		return x.LeftOperator
	}
	return nil
}

func (m *LogicalOperator) GetLeftStringCondition() *StringCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftStringCondition); ok {
		return x.LeftStringCondition
	}
	return nil
}

func (m *LogicalOperator) GetLeftNumberCondition() *NumberCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftNumberCondition); ok {
		return x.LeftNumberCondition
	}
	return nil
}

func (m *LogicalOperator) GetLeftNullCondition() *NullCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftNullCondition); ok {
		return x.LeftNullCondition
	}
	return nil
}

func (m *LogicalOperator) GetLeftStringArrayCondition() *StringArrayCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftStringArrayCondition); ok {
		return x.LeftStringArrayCondition
	}
	return nil
}

func (m *LogicalOperator) GetLeftNumberArrayCondition() *NumberArrayCondition {
	if x, ok := m.GetLeft().(*LogicalOperator_LeftNumberArrayCondition); ok {
		return x.LeftNumberArrayCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightOperator() *LogicalOperator {
	if x, ok := m.GetRight().(*LogicalOperator_RightOperator); ok {
		return x.RightOperator
	}
	return nil
}

func (m *LogicalOperator) GetRightStringCondition() *StringCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightStringCondition); ok {
		return x.RightStringCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightNumberCondition() *NumberCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightNumberCondition); ok {
		return x.RightNumberCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightNullCondition() *NullCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightNullCondition); ok {
		return x.RightNullCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightStringArrayCondition() *StringArrayCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightStringArrayCondition); ok {
		return x.RightStringArrayCondition
	}
	return nil
}

func (m *LogicalOperator) GetRightNumberArrayCondition() *NumberArrayCondition {
	if x, ok := m.GetRight().(*LogicalOperator_RightNumberArrayCondition); ok {
		return x.RightNumberArrayCondition
	}
	return nil
}

func (m *LogicalOperator) GetType() LogicalOperator_Type {
	if m != nil {
		return m.Type
	}
	return LogicalOperator_AND
}

func (m *LogicalOperator) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LogicalOperator) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LogicalOperator_OneofMarshaler, _LogicalOperator_OneofUnmarshaler, _LogicalOperator_OneofSizer, []interface{}{
		(*LogicalOperator_LeftOperator)(nil),
		(*LogicalOperator_LeftStringCondition)(nil),
		(*LogicalOperator_LeftNumberCondition)(nil),
		(*LogicalOperator_LeftNullCondition)(nil),
		(*LogicalOperator_LeftStringArrayCondition)(nil),
		(*LogicalOperator_LeftNumberArrayCondition)(nil),
		(*LogicalOperator_RightOperator)(nil),
		(*LogicalOperator_RightStringCondition)(nil),
		(*LogicalOperator_RightNumberCondition)(nil),
		(*LogicalOperator_RightNullCondition)(nil),
		(*LogicalOperator_RightStringArrayCondition)(nil),
		(*LogicalOperator_RightNumberArrayCondition)(nil),
	}
}

func _LogicalOperator_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LogicalOperator)
	// left
	switch x := m.Left.(type) {
	case *LogicalOperator_LeftOperator:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftOperator); err != nil {
			return err
		}
	case *LogicalOperator_LeftStringCondition:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftStringCondition); err != nil {
			return err
		}
	case *LogicalOperator_LeftNumberCondition:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftNumberCondition); err != nil {
			return err
		}
	case *LogicalOperator_LeftNullCondition:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftNullCondition); err != nil {
			return err
		}
	case *LogicalOperator_LeftStringArrayCondition:
		_ = b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftStringArrayCondition); err != nil {
			return err
		}
	case *LogicalOperator_LeftNumberArrayCondition:
		_ = b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LeftNumberArrayCondition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LogicalOperator.Left has unexpected type %T", x)
	}
	// right
	switch x := m.Right.(type) {
	case *LogicalOperator_RightOperator:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightOperator); err != nil {
			return err
		}
	case *LogicalOperator_RightStringCondition:
		_ = b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightStringCondition); err != nil {
			return err
		}
	case *LogicalOperator_RightNumberCondition:
		_ = b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightNumberCondition); err != nil {
			return err
		}
	case *LogicalOperator_RightNullCondition:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightNullCondition); err != nil {
			return err
		}
	case *LogicalOperator_RightStringArrayCondition:
		_ = b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightStringArrayCondition); err != nil {
			return err
		}
	case *LogicalOperator_RightNumberArrayCondition:
		_ = b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RightNumberArrayCondition); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LogicalOperator.Right has unexpected type %T", x)
	}
	return nil
}

func _LogicalOperator_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LogicalOperator)
	switch tag {
	case 1: // left.left_operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalOperator)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftOperator{msg}
		return true, err
	case 2: // left.left_string_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftStringCondition{msg}
		return true, err
	case 3: // left.left_number_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftNumberCondition{msg}
		return true, err
	case 4: // left.left_null_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NullCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftNullCondition{msg}
		return true, err
	case 11: // left.left_string_array_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringArrayCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftStringArrayCondition{msg}
		return true, err
	case 12: // left.left_number_array_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberArrayCondition)
		err := b.DecodeMessage(msg)
		m.Left = &LogicalOperator_LeftNumberArrayCondition{msg}
		return true, err
	case 5: // right.right_operator
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LogicalOperator)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightOperator{msg}
		return true, err
	case 6: // right.right_string_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightStringCondition{msg}
		return true, err
	case 7: // right.right_number_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightNumberCondition{msg}
		return true, err
	case 8: // right.right_null_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NullCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightNullCondition{msg}
		return true, err
	case 13: // right.right_string_array_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StringArrayCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightStringArrayCondition{msg}
		return true, err
	case 14: // right.right_number_array_condition
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NumberArrayCondition)
		err := b.DecodeMessage(msg)
		m.Right = &LogicalOperator_RightNumberArrayCondition{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LogicalOperator_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LogicalOperator)
	// left
	switch x := m.Left.(type) {
	case *LogicalOperator_LeftOperator:
		s := proto.Size(x.LeftOperator)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftStringCondition:
		s := proto.Size(x.LeftStringCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftNumberCondition:
		s := proto.Size(x.LeftNumberCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftNullCondition:
		s := proto.Size(x.LeftNullCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftStringArrayCondition:
		s := proto.Size(x.LeftStringArrayCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_LeftNumberArrayCondition:
		s := proto.Size(x.LeftNumberArrayCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	// right
	switch x := m.Right.(type) {
	case *LogicalOperator_RightOperator:
		s := proto.Size(x.RightOperator)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightStringCondition:
		s := proto.Size(x.RightStringCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightNumberCondition:
		s := proto.Size(x.RightNumberCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightNullCondition:
		s := proto.Size(x.RightNullCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightStringArrayCondition:
		s := proto.Size(x.RightStringArrayCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *LogicalOperator_RightNumberArrayCondition:
		s := proto.Size(x.RightNumberArrayCondition)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StringCondition represents a condition with a string literal, e.g. field == 'string'.
// field_path is a reference to a value of a resource.
// value is the string literal.
// type is a type of the condition.
// is_negative is set to true if the condition is negated.
type StringCondition struct {
	FieldPath            []string             `protobuf:"bytes,1,rep,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	Value                string               `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Type                 StringCondition_Type `protobuf:"varint,3,opt,name=type,proto3,enum=infoblox.api.StringCondition_Type" json:"type,omitempty"`
	IsNegative           bool                 `protobuf:"varint,4,opt,name=is_negative,json=isNegative,proto3" json:"is_negative,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *StringCondition) Reset()         { *m = StringCondition{} }
func (m *StringCondition) String() string { return proto.CompactTextString(m) }
func (*StringCondition) ProtoMessage()    {}
func (*StringCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{6}
}
func (m *StringCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StringCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringCondition.Merge(dst, src)
}
func (m *StringCondition) XXX_Size() int {
	return m.Size()
}
func (m *StringCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_StringCondition.DiscardUnknown(m)
}

var xxx_messageInfo_StringCondition proto.InternalMessageInfo

func (m *StringCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *StringCondition) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *StringCondition) GetType() StringCondition_Type {
	if m != nil {
		return m.Type
	}
	return StringCondition_EQ
}

func (m *StringCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// NumberCondition represents a condition with a number literal, e.g. field > 3.
// field_path is a reference to a value of a resource.
// value is the number literal.
// type is a type of the condition.
// is_negative is set to true if the condition is negated.
type NumberCondition struct {
	FieldPath            []string             `protobuf:"bytes,1,rep,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	Value                float64              `protobuf:"fixed64,2,opt,name=value,proto3" json:"value,omitempty"`
	Type                 NumberCondition_Type `protobuf:"varint,3,opt,name=type,proto3,enum=infoblox.api.NumberCondition_Type" json:"type,omitempty"`
	IsNegative           bool                 `protobuf:"varint,4,opt,name=is_negative,json=isNegative,proto3" json:"is_negative,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *NumberCondition) Reset()         { *m = NumberCondition{} }
func (m *NumberCondition) String() string { return proto.CompactTextString(m) }
func (*NumberCondition) ProtoMessage()    {}
func (*NumberCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{7}
}
func (m *NumberCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NumberCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberCondition.Merge(dst, src)
}
func (m *NumberCondition) XXX_Size() int {
	return m.Size()
}
func (m *NumberCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NumberCondition proto.InternalMessageInfo

func (m *NumberCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *NumberCondition) GetValue() float64 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *NumberCondition) GetType() NumberCondition_Type {
	if m != nil {
		return m.Type
	}
	return NumberCondition_EQ
}

func (m *NumberCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// NullCondition represents a condition with a null literal, e.g. field == null.
// field_path is a reference to a value of a resource.
// is_negative is set to true if the condition is negated.
type NullCondition struct {
	FieldPath            []string `protobuf:"bytes,1,rep,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	IsNegative           bool     `protobuf:"varint,2,opt,name=is_negative,json=isNegative,proto3" json:"is_negative,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NullCondition) Reset()         { *m = NullCondition{} }
func (m *NullCondition) String() string { return proto.CompactTextString(m) }
func (*NullCondition) ProtoMessage()    {}
func (*NullCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{8}
}
func (m *NullCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NullCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NullCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NullCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NullCondition.Merge(dst, src)
}
func (m *NullCondition) XXX_Size() int {
	return m.Size()
}
func (m *NullCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NullCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NullCondition proto.InternalMessageInfo

func (m *NullCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *NullCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// StringArrayCondition represents a condition with string arrays, e.g. field in ['hello','world']
// field_path is a reference to a value of a resource.
// is_negative is set to true if the condition is negated
type StringArrayCondition struct {
	FieldPath            []string                  `protobuf:"bytes,1,rep,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	Values               []string                  `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	Type                 StringArrayCondition_Type `protobuf:"varint,3,opt,name=type,proto3,enum=infoblox.api.StringArrayCondition_Type" json:"type,omitempty"`
	IsNegative           bool                      `protobuf:"varint,4,opt,name=is_negative,json=isNegative,proto3" json:"is_negative,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *StringArrayCondition) Reset()         { *m = StringArrayCondition{} }
func (m *StringArrayCondition) String() string { return proto.CompactTextString(m) }
func (*StringArrayCondition) ProtoMessage()    {}
func (*StringArrayCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{9}
}
func (m *StringArrayCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StringArrayCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StringArrayCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StringArrayCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringArrayCondition.Merge(dst, src)
}
func (m *StringArrayCondition) XXX_Size() int {
	return m.Size()
}
func (m *StringArrayCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_StringArrayCondition.DiscardUnknown(m)
}

var xxx_messageInfo_StringArrayCondition proto.InternalMessageInfo

func (m *StringArrayCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *StringArrayCondition) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *StringArrayCondition) GetType() StringArrayCondition_Type {
	if m != nil {
		return m.Type
	}
	return StringArrayCondition_IN
}

func (m *StringArrayCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// NumberArrayCondition represents a condition with string arrays, e.g. field in [1, 5, 7]
// field_path is a reference to a value of a resource.
// is_negative is set to true if the condition is negated
type NumberArrayCondition struct {
	FieldPath            []string                  `protobuf:"bytes,1,rep,name=field_path,json=fieldPath,proto3" json:"field_path,omitempty"`
	Values               []float64                 `protobuf:"fixed64,2,rep,packed,name=values,proto3" json:"values,omitempty"`
	Type                 NumberArrayCondition_Type `protobuf:"varint,3,opt,name=type,proto3,enum=infoblox.api.NumberArrayCondition_Type" json:"type,omitempty"`
	IsNegative           bool                      `protobuf:"varint,4,opt,name=is_negative,json=isNegative,proto3" json:"is_negative,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *NumberArrayCondition) Reset()         { *m = NumberArrayCondition{} }
func (m *NumberArrayCondition) String() string { return proto.CompactTextString(m) }
func (*NumberArrayCondition) ProtoMessage()    {}
func (*NumberArrayCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{10}
}
func (m *NumberArrayCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberArrayCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberArrayCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *NumberArrayCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberArrayCondition.Merge(dst, src)
}
func (m *NumberArrayCondition) XXX_Size() int {
	return m.Size()
}
func (m *NumberArrayCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberArrayCondition.DiscardUnknown(m)
}

var xxx_messageInfo_NumberArrayCondition proto.InternalMessageInfo

func (m *NumberArrayCondition) GetFieldPath() []string {
	if m != nil {
		return m.FieldPath
	}
	return nil
}

func (m *NumberArrayCondition) GetValues() []float64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *NumberArrayCondition) GetType() NumberArrayCondition_Type {
	if m != nil {
		return m.Type
	}
	return NumberArrayCondition_IN
}

func (m *NumberArrayCondition) GetIsNegative() bool {
	if m != nil {
		return m.IsNegative
	}
	return false
}

// Pagination represents both server-driven and client-driven pagination request.
// Server-driven pagination is a model in which the server returns some
// amount of data along with an token indicating there is more data
// and where subsequent queries can get the next page of data.
// Client-driven pagination is a model in which rows are addressable by
// offset and page size (limit).
type Pagination struct {
	// The service-defined string used to identify a page of resources.
	// A null value indicates the first page.
	PageToken string `protobuf:"bytes,1,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The integer index of the offset into a collection of resources.
	// If omitted or null the value is assumed to be "0".
	Offset int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	// The integer number of resources to be returned in the response.
	// The service may impose maximum value.
	// If omitted the service may impose a default value.
	Limit                int32    `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pagination) Reset()         { *m = Pagination{} }
func (m *Pagination) String() string { return proto.CompactTextString(m) }
func (*Pagination) ProtoMessage()    {}
func (*Pagination) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{11}
}
func (m *Pagination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pagination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pagination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Pagination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pagination.Merge(dst, src)
}
func (m *Pagination) XXX_Size() int {
	return m.Size()
}
func (m *Pagination) XXX_DiscardUnknown() {
	xxx_messageInfo_Pagination.DiscardUnknown(m)
}

var xxx_messageInfo_Pagination proto.InternalMessageInfo

func (m *Pagination) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *Pagination) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *Pagination) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// PageInfo represents both server-driven and client-driven pagination response.
// Server-driven pagination is a model in which the server returns some
// amount of data along with an token indicating there is more data
// and where subsequent queries can get the next page of data.
// Client-driven pagination is a model in which rows are addressable by
// offset and page size (limit).
type PageInfo struct {
	// The service response should contain a string to indicate
	// the next page of resources.
	// A null value indicates no more pages.
	PageToken string `protobuf:"bytes,1,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	// The service may optionally include the total number of resources being paged.
	Size_ int32 `protobuf:"varint,2,opt,name=size,proto3" json:"size,omitempty"`
	// The service may optionally include the offset of the next page of resources.
	// A null value indicates no more pages.
	Offset               int32    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PageInfo) Reset()         { *m = PageInfo{} }
func (m *PageInfo) String() string { return proto.CompactTextString(m) }
func (*PageInfo) ProtoMessage()    {}
func (*PageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_collection_operators_d4969702bbadf5db, []int{12}
}
func (m *PageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PageInfo.Merge(dst, src)
}
func (m *PageInfo) XXX_Size() int {
	return m.Size()
}
func (m *PageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PageInfo proto.InternalMessageInfo

func (m *PageInfo) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

func (m *PageInfo) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *PageInfo) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func init() {
	proto.RegisterType((*SortCriteria)(nil), "infoblox.api.SortCriteria")
	proto.RegisterType((*Sorting)(nil), "infoblox.api.Sorting")
	proto.RegisterType((*FieldSelection)(nil), "infoblox.api.FieldSelection")
	proto.RegisterMapType((map[string]*Field)(nil), "infoblox.api.FieldSelection.FieldsEntry")
	proto.RegisterType((*Field)(nil), "infoblox.api.Field")
	proto.RegisterMapType((map[string]*Field)(nil), "infoblox.api.Field.SubsEntry")
	proto.RegisterType((*Filtering)(nil), "infoblox.api.Filtering")
	proto.RegisterType((*LogicalOperator)(nil), "infoblox.api.LogicalOperator")
	proto.RegisterType((*StringCondition)(nil), "infoblox.api.StringCondition")
	proto.RegisterType((*NumberCondition)(nil), "infoblox.api.NumberCondition")
	proto.RegisterType((*NullCondition)(nil), "infoblox.api.NullCondition")
	proto.RegisterType((*StringArrayCondition)(nil), "infoblox.api.StringArrayCondition")
	proto.RegisterType((*NumberArrayCondition)(nil), "infoblox.api.NumberArrayCondition")
	proto.RegisterType((*Pagination)(nil), "infoblox.api.Pagination")
	proto.RegisterType((*PageInfo)(nil), "infoblox.api.PageInfo")
	proto.RegisterEnum("infoblox.api.SortCriteria_Order", SortCriteria_Order_name, SortCriteria_Order_value)
	proto.RegisterEnum("infoblox.api.LogicalOperator_Type", LogicalOperator_Type_name, LogicalOperator_Type_value)
	proto.RegisterEnum("infoblox.api.StringCondition_Type", StringCondition_Type_name, StringCondition_Type_value)
	proto.RegisterEnum("infoblox.api.NumberCondition_Type", NumberCondition_Type_name, NumberCondition_Type_value)
	proto.RegisterEnum("infoblox.api.StringArrayCondition_Type", StringArrayCondition_Type_name, StringArrayCondition_Type_value)
	proto.RegisterEnum("infoblox.api.NumberArrayCondition_Type", NumberArrayCondition_Type_name, NumberArrayCondition_Type_value)
}
func (m *SortCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SortCriteria) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(len(m.Tag)))
		i += copy(dAtA[i:], m.Tag)
	}
	if m.Order != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Sorting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sorting) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Criterias) > 0 {
		for _, msg := range m.Criterias {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCollectionOperators(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FieldSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FieldSelection) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, _ := range m.Fields {
			dAtA[i] = 0xa
			i++
			v := m.Fields[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCollectionOperators(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCollectionOperators(uint64(len(k))) + msgSize
			i = encodeVarintCollectionOperators(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCollectionOperators(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCollectionOperators(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Field) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Field) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Subs) > 0 {
		for k, _ := range m.Subs {
			dAtA[i] = 0x12
			i++
			v := m.Subs[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovCollectionOperators(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovCollectionOperators(uint64(len(k))) + msgSize
			i = encodeVarintCollectionOperators(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintCollectionOperators(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintCollectionOperators(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Filtering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filtering) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Root != nil {
		nn3, err := m.Root.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Filtering_Operator) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Operator != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Operator.Size()))
		n4, err := m.Operator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *Filtering_StringCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringCondition != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.StringCondition.Size()))
		n5, err := m.StringCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}
func (m *Filtering_NumberCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NumberCondition != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.NumberCondition.Size()))
		n6, err := m.NumberCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *Filtering_NullCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NullCondition != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.NullCondition.Size()))
		n7, err := m.NullCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *Filtering_StringArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.StringArrayCondition != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.StringArrayCondition.Size()))
		n8, err := m.StringArrayCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *Filtering_NumberArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.NumberArrayCondition != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.NumberArrayCondition.Size()))
		n9, err := m.NumberArrayCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}
func (m *LogicalOperator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogicalOperator) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Left != nil {
		nn10, err := m.Left.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn10
	}
	if m.Right != nil {
		nn11, err := m.Right.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn11
	}
	if m.Type != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Type))
	}
	if m.IsNegative {
		dAtA[i] = 0x50
		i++
		if m.IsNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogicalOperator_LeftOperator) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LeftOperator != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.LeftOperator.Size()))
		n12, err := m.LeftOperator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}
func (m *LogicalOperator_LeftStringCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LeftStringCondition != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.LeftStringCondition.Size()))
		n13, err := m.LeftStringCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}
func (m *LogicalOperator_LeftNumberCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LeftNumberCondition != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.LeftNumberCondition.Size()))
		n14, err := m.LeftNumberCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}
func (m *LogicalOperator_LeftNullCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LeftNullCondition != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.LeftNullCondition.Size()))
		n15, err := m.LeftNullCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}
func (m *LogicalOperator_RightOperator) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RightOperator != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.RightOperator.Size()))
		n16, err := m.RightOperator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}
func (m *LogicalOperator_RightStringCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RightStringCondition != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.RightStringCondition.Size()))
		n17, err := m.RightStringCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *LogicalOperator_RightNumberCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RightNumberCondition != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.RightNumberCondition.Size()))
		n18, err := m.RightNumberCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *LogicalOperator_RightNullCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RightNullCondition != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.RightNullCondition.Size()))
		n19, err := m.RightNullCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *LogicalOperator_LeftStringArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LeftStringArrayCondition != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.LeftStringArrayCondition.Size()))
		n20, err := m.LeftStringArrayCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *LogicalOperator_LeftNumberArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.LeftNumberArrayCondition != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.LeftNumberArrayCondition.Size()))
		n21, err := m.LeftNumberArrayCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *LogicalOperator_RightStringArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RightStringArrayCondition != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.RightStringArrayCondition.Size()))
		n22, err := m.RightStringArrayCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *LogicalOperator_RightNumberArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.RightNumberArrayCondition != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.RightNumberArrayCondition.Size()))
		n23, err := m.RightNumberArrayCondition.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}
func (m *StringCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Type))
	}
	if m.IsNegative {
		dAtA[i] = 0x20
		i++
		if m.IsNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NumberCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Value != 0 {
		dAtA[i] = 0x11
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Value))))
		i += 8
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Type))
	}
	if m.IsNegative {
		dAtA[i] = 0x20
		i++
		if m.IsNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NullCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NullCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.IsNegative {
		dAtA[i] = 0x10
		i++
		if m.IsNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StringArrayCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StringArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Type))
	}
	if m.IsNegative {
		dAtA[i] = 0x20
		i++
		if m.IsNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NumberArrayCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberArrayCondition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Values) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(len(m.Values)*8))
		for _, num := range m.Values {
			f24 := math.Float64bits(float64(num))
			encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(f24))
			i += 8
		}
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Type))
	}
	if m.IsNegative {
		dAtA[i] = 0x20
		i++
		if m.IsNegative {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Pagination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pagination) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PageToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.Offset != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Offset))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PageInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PageToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(len(m.PageToken)))
		i += copy(dAtA[i:], m.PageToken)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Size_))
	}
	if m.Offset != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCollectionOperators(dAtA, i, uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintCollectionOperators(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SortCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	if m.Order != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Order))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Sorting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Criterias) > 0 {
		for _, e := range m.Criterias {
			l = e.Size()
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FieldSelection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Fields) > 0 {
		for k, v := range m.Fields {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCollectionOperators(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCollectionOperators(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCollectionOperators(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Field) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	if len(m.Subs) > 0 {
		for k, v := range m.Subs {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovCollectionOperators(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovCollectionOperators(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCollectionOperators(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filtering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Root != nil {
		n += m.Root.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Filtering_Operator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Operator != nil {
		l = m.Operator.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *Filtering_StringCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StringCondition != nil {
		l = m.StringCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *Filtering_NumberCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumberCondition != nil {
		l = m.NumberCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *Filtering_NullCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NullCondition != nil {
		l = m.NullCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *Filtering_StringArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StringArrayCondition != nil {
		l = m.StringArrayCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *Filtering_NumberArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumberArrayCondition != nil {
		l = m.NumberArrayCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		n += m.Left.Size()
	}
	if m.Right != nil {
		n += m.Right.Size()
	}
	if m.Type != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Type))
	}
	if m.IsNegative {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogicalOperator_LeftOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftOperator != nil {
		l = m.LeftOperator.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_LeftStringCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftStringCondition != nil {
		l = m.LeftStringCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_LeftNumberCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftNumberCondition != nil {
		l = m.LeftNumberCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_LeftNullCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftNullCondition != nil {
		l = m.LeftNullCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_RightOperator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RightOperator != nil {
		l = m.RightOperator.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_RightStringCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RightStringCondition != nil {
		l = m.RightStringCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_RightNumberCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RightNumberCondition != nil {
		l = m.RightNumberCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_RightNullCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RightNullCondition != nil {
		l = m.RightNullCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_LeftStringArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftStringArrayCondition != nil {
		l = m.LeftStringArrayCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_LeftNumberArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LeftNumberArrayCondition != nil {
		l = m.LeftNumberArrayCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_RightStringArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RightStringArrayCondition != nil {
		l = m.RightStringArrayCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *LogicalOperator_RightNumberArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RightNumberArrayCondition != nil {
		l = m.RightNumberArrayCondition.Size()
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	return n
}
func (m *StringCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			l = len(s)
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Type))
	}
	if m.IsNegative {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NumberCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			l = len(s)
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	if m.Value != 0 {
		n += 9
	}
	if m.Type != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Type))
	}
	if m.IsNegative {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NullCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			l = len(s)
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	if m.IsNegative {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StringArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			l = len(s)
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Type))
	}
	if m.IsNegative {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NumberArrayCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FieldPath) > 0 {
		for _, s := range m.FieldPath {
			l = len(s)
			n += 1 + l + sovCollectionOperators(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		n += 1 + sovCollectionOperators(uint64(len(m.Values)*8)) + len(m.Values)*8
	}
	if m.Type != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Type))
	}
	if m.IsNegative {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pagination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovCollectionOperators(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Size_))
	}
	if m.Offset != 0 {
		n += 1 + sovCollectionOperators(uint64(m.Offset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovCollectionOperators(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCollectionOperators(x uint64) (n int) {
	return sovCollectionOperators(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SortCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SortCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SortCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (SortCriteria_Order(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sorting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sorting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sorting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Criterias", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Criterias = append(m.Criterias, &SortCriteria{})
			if err := m.Criterias[len(m.Criterias)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FieldSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FieldSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FieldSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = make(map[string]*Field)
			}
			var mapkey string
			var mapvalue *Field
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollectionOperators
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollectionOperators
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollectionOperators
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Field{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCollectionOperators(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Fields[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Field) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Field: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Field: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subs == nil {
				m.Subs = make(map[string]*Field)
			}
			var mapkey string
			var mapvalue *Field
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollectionOperators
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollectionOperators
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCollectionOperators
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Field{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCollectionOperators(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthCollectionOperators
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Subs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filtering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filtering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filtering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Root = &Filtering_Operator{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Root = &Filtering_StringCondition{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumberCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Root = &Filtering_NumberCondition{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NullCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NullCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Root = &Filtering_NullCondition{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringArrayCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringArrayCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Root = &Filtering_StringArrayCondition{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberArrayCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumberArrayCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Root = &Filtering_NumberArrayCondition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogicalOperator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogicalOperator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogicalOperator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftOperator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Left = &LogicalOperator_LeftOperator{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftStringCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Left = &LogicalOperator_LeftStringCondition{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftNumberCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumberCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Left = &LogicalOperator_LeftNumberCondition{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftNullCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NullCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Left = &LogicalOperator_LeftNullCondition{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightOperator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LogicalOperator{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Right = &LogicalOperator_RightOperator{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightStringCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Right = &LogicalOperator_RightStringCondition{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightNumberCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumberCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Right = &LogicalOperator_RightNumberCondition{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightNullCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NullCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Right = &LogicalOperator_RightNullCondition{v}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (LogicalOperator_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNegative = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftStringArrayCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringArrayCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Left = &LogicalOperator_LeftStringArrayCondition{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftNumberArrayCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumberArrayCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Left = &LogicalOperator_LeftNumberArrayCondition{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightStringArrayCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StringArrayCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Right = &LogicalOperator_RightStringArrayCondition{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightNumberArrayCondition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NumberArrayCondition{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Right = &LogicalOperator_RightNumberArrayCondition{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = append(m.FieldPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StringCondition_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNegative = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumberCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = append(m.FieldPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = float64(math.Float64frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NumberCondition_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNegative = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NullCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NullCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NullCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = append(m.FieldPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNegative = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StringArrayCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StringArrayCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StringArrayCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = append(m.FieldPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (StringArrayCondition_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNegative = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumberArrayCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberArrayCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberArrayCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = append(m.FieldPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
				iNdEx += 8
				v2 := float64(math.Float64frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCollectionOperators
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCollectionOperators
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 8
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]float64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
					iNdEx += 8
					v2 := float64(math.Float64frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (NumberArrayCondition_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNegative", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNegative = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pagination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pagination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pagination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCollectionOperators(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCollectionOperators
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCollectionOperators(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCollectionOperators
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCollectionOperators
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCollectionOperators
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCollectionOperators
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCollectionOperators(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCollectionOperators = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCollectionOperators   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("query/collection_operators.proto", fileDescriptor_collection_operators_d4969702bbadf5db)
}

var fileDescriptor_collection_operators_d4969702bbadf5db = []byte{
	// 1038 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x97, 0x41, 0x6f, 0xe2, 0x46,
	0x14, 0xc7, 0x19, 0xb0, 0x09, 0x7e, 0x04, 0xe2, 0x4e, 0x68, 0x4a, 0xb3, 0xdd, 0x14, 0xf9, 0x52,
	0x7a, 0x58, 0xd2, 0xa6, 0xd2, 0x6a, 0xd5, 0x48, 0x55, 0x13, 0x42, 0x9a, 0x54, 0x59, 0xc8, 0x1a,
	0xf6, 0xd0, 0xbd, 0x20, 0x43, 0x06, 0x67, 0x14, 0xc7, 0x43, 0xed, 0x61, 0x55, 0xfa, 0x59, 0x7a,
	0xea, 0x47, 0xe8, 0xb5, 0x5f, 0xa0, 0xb7, 0xf6, 0x23, 0x54, 0xa9, 0xd4, 0xcf, 0xb1, 0x9a, 0x61,
	0x20, 0xc6, 0x38, 0x0b, 0x6c, 0x2e, 0x6b, 0xcf, 0xdb, 0xf7, 0x7e, 0xef, 0xbd, 0xff, 0xbc, 0xc9,
	0x18, 0xa8, 0xfc, 0x3c, 0x22, 0xc1, 0x78, 0xbf, 0xcf, 0x3c, 0x8f, 0xf4, 0x39, 0x65, 0x7e, 0x97,
	0x0d, 0x49, 0xe0, 0x70, 0x16, 0x84, 0xb5, 0x61, 0xc0, 0x38, 0xc3, 0x9b, 0xd4, 0x1f, 0xb0, 0x9e,
	0xc7, 0x7e, 0xa9, 0x39, 0x43, 0x6a, 0x71, 0xd8, 0x6c, 0xb3, 0x80, 0xd7, 0x03, 0xca, 0x49, 0x40,
	0x1d, 0x6c, 0x42, 0x86, 0x3b, 0x6e, 0x19, 0x55, 0x50, 0xd5, 0xb0, 0xc5, 0x2b, 0x7e, 0x0e, 0x3a,
	0x0b, 0xae, 0x48, 0x50, 0x4e, 0x57, 0x50, 0xb5, 0x78, 0x50, 0xa9, 0x45, 0xe3, 0x6b, 0xd1, 0xe0,
	0x5a, 0x4b, 0xf8, 0xd9, 0x13, 0x77, 0x6b, 0x17, 0x74, 0xb9, 0xc6, 0x1b, 0x90, 0x39, 0x6a, 0xd7,
	0xcd, 0x14, 0xce, 0x81, 0x76, 0xd2, 0x68, 0xd7, 0x4d, 0x64, 0xd5, 0x61, 0x43, 0x04, 0x52, 0xdf,
	0xc5, 0x2f, 0xc0, 0xe8, 0xab, 0xf8, 0xb0, 0x8c, 0x2a, 0x99, 0x6a, 0xfe, 0x60, 0xf7, 0xe1, 0x14,
	0xf6, 0xbd, 0xb3, 0xf5, 0x3b, 0x82, 0xe2, 0x29, 0x25, 0xde, 0x55, 0x9b, 0xa8, 0x5e, 0xf1, 0xf7,
	0x90, 0x1d, 0x08, 0xcb, 0x94, 0x54, 0x9d, 0x27, 0xcd, 0x7b, 0x4f, 0x96, 0x61, 0xc3, 0xe7, 0xc1,
	0xd8, 0x56, 0x71, 0xbb, 0x4d, 0xc8, 0x47, 0xcc, 0x42, 0x8e, 0x1b, 0x32, 0x9e, 0xca, 0x71, 0x43,
	0xc6, 0xf8, 0x4b, 0xd0, 0xdf, 0x3a, 0xde, 0x88, 0x48, 0x39, 0xf2, 0x07, 0xdb, 0x09, 0x19, 0xec,
	0x89, 0xc7, 0xb7, 0xe9, 0x17, 0xc8, 0xfa, 0x0d, 0x81, 0x2e, 0x8d, 0x18, 0x83, 0xe6, 0x3b, 0xb7,
	0x44, 0xb1, 0xe4, 0x3b, 0xfe, 0x1a, 0xb4, 0x70, 0xd4, 0x0b, 0xcb, 0x69, 0x59, 0xed, 0xd3, 0x04,
	0x56, 0xad, 0x3d, 0xea, 0xa9, 0x12, 0xa5, 0xeb, 0xee, 0x05, 0x18, 0x33, 0xd3, 0xe3, 0xcb, 0xfb,
	0x3f, 0x03, 0xc6, 0x29, 0xf5, 0x84, 0xa2, 0xbe, 0x8b, 0x0f, 0x21, 0x37, 0x9d, 0x16, 0xc9, 0x5c,
	0x28, 0xe9, 0x82, 0xb9, 0xb4, 0xef, 0x78, 0x2d, 0xe5, 0x74, 0x96, 0xb2, 0x67, 0x01, 0xf8, 0x47,
	0x30, 0x43, 0x2e, 0x30, 0xdd, 0x3e, 0xf3, 0xaf, 0xa8, 0x50, 0x58, 0x15, 0x11, 0x83, 0xb4, 0xa5,
	0x57, 0x7d, 0xea, 0x74, 0x96, 0xb2, 0xb7, 0xc2, 0x79, 0x93, 0x60, 0xf9, 0xa3, 0xdb, 0x1e, 0x09,
	0x22, 0xac, 0x4c, 0x12, 0xab, 0x29, 0xbd, 0xe6, 0x58, 0xfe, 0xbc, 0x09, 0x9f, 0x40, 0xd1, 0x1f,
	0x79, 0x5e, 0x84, 0xa4, 0x49, 0xd2, 0x93, 0x38, 0xc9, 0xf3, 0xa2, 0x9c, 0x82, 0x1f, 0x35, 0xe0,
	0x37, 0xb0, 0xa3, 0xba, 0x73, 0x82, 0xc0, 0x19, 0x47, 0x68, 0xba, 0xa4, 0x59, 0x49, 0x3d, 0x1e,
	0x09, 0xd7, 0x28, 0xb4, 0x14, 0x26, 0xd8, 0x05, 0x5b, 0x75, 0x1b, 0x67, 0x67, 0x93, 0xd8, 0x93,
	0x9e, 0x17, 0xd9, 0x7e, 0x82, 0xfd, 0x38, 0x0b, 0x5a, 0xc0, 0x18, 0xb7, 0xfe, 0x30, 0x60, 0x2b,
	0xb6, 0x7b, 0xf8, 0x04, 0x0a, 0x1e, 0x19, 0xf0, 0xee, 0xba, 0x7b, 0xbe, 0x29, 0xa2, 0x66, 0x94,
	0x36, 0x7c, 0x2c, 0x29, 0x1f, 0xba, 0xf9, 0xdb, 0x22, 0x3a, 0x66, 0x9e, 0x41, 0x3f, 0x74, 0x0a,
	0x24, 0x34, 0x66, 0xc6, 0x2f, 0x61, 0x5b, 0x41, 0xd7, 0x1f, 0x87, 0x8f, 0x26, 0xc0, 0xe8, 0x48,
	0x9c, 0x42, 0x31, 0xa0, 0xee, 0x75, 0x44, 0x3f, 0x7d, 0x15, 0xfd, 0x90, 0x5d, 0x90, 0x61, 0x33,
	0x01, 0x5f, 0xc3, 0xce, 0x84, 0xb3, 0xa0, 0x60, 0x76, 0x15, 0x05, 0x91, 0x5d, 0x92, 0xe1, 0x71,
	0x09, 0x67, 0xd8, 0x05, 0x0d, 0x37, 0x56, 0xd1, 0x70, 0x8a, 0x8d, 0x8b, 0xd8, 0x82, 0xd2, 0x14,
	0x3b, 0xa7, 0x62, 0x6e, 0xb9, 0x8a, 0xc8, 0xc6, 0x0a, 0x19, 0x95, 0xf1, 0x39, 0x68, 0x7c, 0x3c,
	0x24, 0x65, 0x43, 0x5e, 0x2f, 0xd6, 0x7b, 0xc5, 0xab, 0x75, 0xc6, 0x43, 0x62, 0x4b, 0x7f, 0xfc,
	0x39, 0xe4, 0x69, 0xd8, 0xf5, 0x89, 0xeb, 0x70, 0xfa, 0x96, 0x94, 0xa1, 0x82, 0xaa, 0x39, 0x1b,
	0x68, 0xd8, 0x54, 0x16, 0xdc, 0x87, 0x27, 0xd1, 0xc1, 0x8c, 0x9f, 0xad, 0xfc, 0x1a, 0xe7, 0xb6,
	0x7c, 0x3f, 0xa3, 0xb1, 0xb3, 0x3b, 0x4d, 0xf2, 0xc0, 0x01, 0xde, 0x5c, 0xe3, 0x00, 0x97, 0xef,
	0x67, 0x36, 0x96, 0x84, 0xc0, 0x67, 0x73, 0x13, 0x12, 0xcf, 0x52, 0x58, 0xb9, 0x15, 0x64, 0x7f,
	0x1a, 0x19, 0x96, 0x87, 0xd2, 0x3c, 0xd0, 0x4c, 0x71, 0xe5, 0x66, 0xa6, 0x69, 0x92, 0xfe, 0xd3,
	0xfa, 0x04, 0x34, 0xb1, 0x8d, 0xf2, 0xbb, 0xa0, 0x79, 0x62, 0xa6, 0x70, 0x16, 0xd2, 0x2d, 0xdb,
	0x44, 0xe2, 0x6f, 0x95, 0x90, 0xe0, 0x78, 0x03, 0x74, 0x19, 0x6d, 0xfd, 0x87, 0x60, 0x2b, 0x3e,
	0xd6, 0x4f, 0x01, 0xe4, 0x55, 0xdd, 0x1d, 0x3a, 0xfc, 0x5a, 0x5e, 0xf3, 0x86, 0x6d, 0x48, 0xcb,
	0xa5, 0xc3, 0xaf, 0x71, 0x29, 0x7a, 0xff, 0x19, 0xea, 0xaa, 0x9b, 0xcd, 0x58, 0x26, 0x69, 0xc6,
	0x62, 0x19, 0xde, 0x33, 0x63, 0x5a, 0x7c, 0xc6, 0xac, 0x63, 0xd5, 0x4b, 0x16, 0xd2, 0x8d, 0x57,
	0x66, 0x0a, 0x1b, 0xa0, 0xbf, 0x3c, 0xea, 0xd4, 0xcf, 0x4c, 0x24, 0x4c, 0x3f, 0x74, 0xcc, 0xb4,
	0x7c, 0x36, 0xcc, 0x8c, 0x78, 0x5e, 0x74, 0x4c, 0x4d, 0x3e, 0x1b, 0xa6, 0x2e, 0xda, 0x3f, 0x6f,
	0xbc, 0x32, 0xb3, 0xd6, 0xdf, 0x08, 0xb6, 0xe2, 0xa7, 0x6c, 0x9d, 0x2e, 0xd1, 0x4a, 0x5d, 0xc6,
	0x32, 0xac, 0xd5, 0x65, 0x2d, 0xd6, 0xe5, 0xa4, 0x35, 0xa4, 0x5a, 0x4b, 0xab, 0xd6, 0x32, 0xaa,
	0x35, 0xcd, 0x6a, 0x41, 0x61, 0xfe, 0x8c, 0x2f, 0x69, 0x27, 0x56, 0x40, 0x7a, 0xa1, 0x80, 0x3f,
	0x11, 0x94, 0x12, 0x47, 0x76, 0x09, 0x78, 0x07, 0xb2, 0x52, 0x9a, 0xc9, 0x17, 0x96, 0x61, 0xab,
	0x15, 0x3e, 0x9c, 0x53, 0xea, 0x8b, 0xe5, 0x07, 0x67, 0x2d, 0xb9, 0x8a, 0xf7, 0x72, 0x9d, 0x37,
	0xcd, 0x94, 0xac, 0x3e, 0xf1, 0x5c, 0xaf, 0x55, 0x3d, 0x5a, 0xad, 0xfa, 0xa4, 0x44, 0x8f, 0xaa,
	0xfe, 0x27, 0x80, 0x4b, 0xc7, 0xa5, 0xbe, 0x33, 0x2d, 0x79, 0xe8, 0xb8, 0xa4, 0xcb, 0xd9, 0x0d,
	0xf1, 0xd5, 0x87, 0xa7, 0x21, 0x2c, 0x1d, 0x61, 0x10, 0x25, 0xb3, 0xc1, 0x20, 0x24, 0x5c, 0x6e,
	0xa2, 0x6e, 0xab, 0x95, 0x18, 0x58, 0x8f, 0xde, 0x52, 0x2e, 0x6b, 0xd6, 0xed, 0xc9, 0xc2, 0x7a,
	0x0d, 0xb9, 0x4b, 0xc7, 0x25, 0xe7, 0xfe, 0x80, 0x2d, 0x03, 0x63, 0xd0, 0x42, 0xfa, 0x2b, 0x51,
	0x58, 0xf9, 0x1e, 0x49, 0x96, 0x89, 0x26, 0x3b, 0xfe, 0xee, 0xaf, 0xbb, 0x3d, 0xf4, 0xcf, 0xdd,
	0x1e, 0xfa, 0xf7, 0x6e, 0x0f, 0xbd, 0xf9, 0xca, 0xa5, 0xfc, 0x7a, 0xd4, 0xab, 0xf5, 0xd9, 0xed,
	0x7e, 0x40, 0x5d, 0x46, 0x19, 0xdf, 0x77, 0xb8, 0xe7, 0x84, 0xcf, 0x9c, 0xe1, 0xf0, 0x19, 0x67,
	0xcc, 0xbb, 0xa1, 0x7c, 0x5f, 0xfe, 0x6c, 0x3a, 0x94, 0xff, 0xf6, 0xb2, 0xf2, 0x87, 0xd2, 0x37,
	0xef, 0x02, 0x00, 0x00, 0xff, 0xff, 0x0d, 0xfd, 0x74, 0xe2, 0x4c, 0x0d, 0x00, 0x00,
}
